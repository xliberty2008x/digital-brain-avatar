# Модуль 2: Стратегії авторизації в ADK

Це розшифровка того уривка з документації, який ти скинув. Давай перекладемо це на "людську" мову в контексті нашого проєкту.

## 1. Agent-Auth (Авторизація через ідентичність Агента)
Уяви, що твій Агент — це окремий співробітник твоєї компанії. У нього є власний "корпоративний пропуск".
- **Як це працює**: Коли Агент хоче щось записати в базу Neo4j, він показує *свій* токен. База знає: "О, це мій Writer-Agent, йому можна писати".
- **Нащо це нам?**: Це ідеально для фонових задач, де Агент сам вирішує, що робити, і йому не потрібне підтвердження від тебе на кожну дію.
- **Ризик**: Якщо Агента "зламають", він має доступ до всього, на що йому дали права, незалежно від того, хто до нього звернувся.

## 2. User-Auth (Авторизація через ідентичність Користувача)
Тут Агент — це просто твій "посильний". Він не має власних прав, він діє від твого імені.
- **Як це працює**: Агент каже тобі: "Слухай, мені треба запостити це в Telegram, але в мене немає ключа. Дай мені свій тимчасовий ключ (OAuth token)". Ти даєш йому цей ключ. Тепер Агент може зробити *тільки те*, що можеш зробити ти.
- **Нащо це нам?**: Це найнадійніший спосіб. Якщо Агент захоче видалити твої файли, а у тебе (користувача) немає на це прав — система його зупинить.
- **Механіка**: Це і є той самий OAuth Flow, де з'являється вікно "Дозволити застосунку доступ до ваших даних?".

## 3. Що ми будемо робити в проєкті?
Ми почнемо з **Agent-Auth**, щоб ти зрозумів механіку JWT. Потім ми перейдемо до **User-Auth**, щоб ти побачив, як правильно делегувати права.

---
### Твоє розуміння:
Коли ти будеш проектувати архітектуру, подумай: цей інструмент має працювати "завжди" від імені системи (Agent-Auth), чи він має залежати від того, хто зараз спілкується з ботом (User-Auth)?
